### Threads in V8
When V8 executes JavaScript it will do so with a single thread, so all JavaScript
functions will be pushed onto the same call stack (within a single isolate that is).

But we can see that when V8 starts it will allocate threads.

If we take a look at the hello_world example we can see that we create a new
Platform:
```c++
  std::unique_ptr<Platform> platform = platform::NewDefaultPlatform();
```

### Platform
`Platform` is declared in `include/v8-platform.h`. The indended user of this 
abstract class is embedders which are expected to extends it. But there is
also  a default implementation in `src/libplatform/default-platform.h`

```c++
class Platform {                                                                
 public:
  ...
  virtual int NumberOfWorkerThreads() = 0;
  virtual std::shared_ptr<v8::TaskRunner> GetForegroundTaskRunner(Isolate* isolate) = 0;
  virtual void CallOnWorkerThread(std::unique_ptr<Task> task) = 0; 
  virtual std::unique_ptr<JobHandle> PostJob(TaskPriority priority,
      std::unique_ptr<JobTask> job_task) {               
    return nullptr;
};
```

### DefaultPlatform
This is the default Platform implementation that ships with V8.

```c++
class V8_PLATFORM_EXPORT DefaultPlatform : public NON_EXPORTED_BASE(Platform) { 
 public:                                                                           
  explicit DefaultPlatform(                                                        
      int thread_pool_size = 0,                                                    
      IdleTaskSupport idle_task_support = IdleTaskSupport::kDisabled,              
      std::unique_ptr<v8::TracingController> tracing_controller = {}); 
 private:
  std::shared_ptr<DefaultWorkerThreadsTaskRunner> worker_threads_task_runner_;

  std::map<v8::Isolate*, std::shared_ptr<DefaultForegroundTaskRunner>>
      foreground_task_runner_map_;
```

`IdelTaskSupport` is an enum defined in `libplatform.h`:
```c++
enum class IdleTaskSupport { kDisabled, kEnabled };
```
And we can see that if it is not specified it will be `kDisabled`.
I'm currently most interested in how and what threads are used for and the
max number of threads is:
```c++
constexpr int kMaxThreadPoolSize = 16;
```
If this value is not specified explicitely we can see above that it will get
a default value of 0, in which case the number of threads will be the number
of processors -1 (or kMaxThreadPoolSize). 

If we look at the private members of DefaultPlatform we can see that it has a
field named `worker_threads_task_runner_` which is of type
`DefaultWorkerThreadsTaskRunner` and this class is declared in 
`src/libplatform/default-worker-threads-task-runner.h`.
```c++
class V8_PLATFORM_EXPORT DefaultWorkerThreadsTaskRunner                            
    : public NON_EXPORTED_BASE(TaskRunner) {
 public:
  using TimeFunction = double (*)();
  DefaultWorkerThreadsTaskRunner(uint32_t thread_pool_size, TimeFunction time_function);
  ...
 private:
  class WorkerThread : public base::Thread {
   public:
    explicit WorkerThread(DefaultWorkerThreadsTaskRunner* runner);
    ~WorkerThread() override;
    // This thread attempts to get tasks in a loop from |runner_| and run them.
    void Run() override;
   private:
    DefaultWorkerThreadsTaskRunner* runner_;
    DISALLOW_COPY_AND_ASSIGN(WorkerThread);
  };

  std::vector<std::unique_ptr<WorkerThread>> thread_pool_; 
}
```
We can find the concrete implementation in `src/libplatform/default-worker-threads-task-runner.cc'.
```c++
DefaultWorkerThreadsTaskRunner::DefaultWorkerThreadsTaskRunner(
    uint32_t thread_pool_size, TimeFunction time_function)
    : queue_(time_function), time_function_(time_function) {
  for (uint32_t i = 0; i < thread_pool_size; ++i) {
    thread_pool_.push_back(std::make_unique<WorkerThread>(this));
  }
}
```
Notice that the above will create `thread_pool_size` of `WorkerThread` instances
and put them into the vector `thread_pool_`.
So we can see above that WorkerThread extends `base::Thread` which is declared
in `src/base/platform/platform.h`.

Now, what kind of things tasks are submitted to this pool of threads?  
One example is when compiling wasm:
```c++
  V8::GetCurrentPlatform()->CallOnWorkerThread(std::move(task));
```
Also there are may calls from the heap namespace with handles garbage collection.



### TaskRunner
If declared in `include/v8-platform.h`
```c++
class Task {
 public:
  virtual ~Task() = default;
  virtual void Run() = 0;
};

class TaskRunner {
 public:
  virtual void PostTask(std::unique_ptr<Task> task) = 0; 
  ...
```

### TracingController
TODO: This might be better off in a separate notes file.

```console
 ../v8_src/v8/out/x64.release_gcc/d8 --enable-tracing -e 'console.log("bajja");'
```
Now we can open chrome://inspect and load the file named `v8_trace.json` that
was generated by using the `--enable-tracing` option.
[link](https://v8.dev/docs/trace) to V8 tracing docs.

